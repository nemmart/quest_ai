This project contains several components.  It contains an emulator for a Data General MV-32 Eagle computer and
and an emulator for a minimal set of AOS/VS operating system calls.  The operating system calls are mapped to
Windows/C++ calls.  The emulators are written in Java and can be found in the Source directory.

The project also includes a game called QUEST.  Quest consists of two processes that must be running simultaneous
on the emulation.  QUEST and QUEST_SERVER.  They communicate through shared memory that is mapped into each process.
The binary program can be found in the QUEST folder: QUEST.PR and QUEST_SERVER.PR.  The associated symbol tables for
the two programs are QUEST.ST and QUEST_SERVER.SR.

The project has a simple disassembler and symbol table dumper.  Quest has been disassembled into quest.dis and the
symbols have been dumped into quest.symbols, likewise for quest_server.dis.

The original Quest program was probably written in either F77 or PL/I and compiled to the .PR files.  The original 
source code for Quest and Quest_Server has been lost.  Your project is to try to reverse engineer the .PR file 
back to some source code that could be compiled.  

Some useful information.  Within the Source folder, you'll find hw which is the instruction set emulation.  You'll
also find os which contains the emulation of the operating system.  Debug has tools for loading and dumping information
about the programs.  The Docs folders contains documentation about AOS/VS system calls and the instruction set.

There is a final calls CONCEPTS which gives some background on the game.

The main code files that you will be working with are:
  quest.symbols
  quest.compact

  quest_server.symbols
  quest_server.symbols
  
These files where generated using the java programs:
  Compile all the java code in the Source folder
  Use jar to package all the compiled java code into quest.jar
  
  java -cp quest.jar debug.SymbolTable quest/quest.st >quest.symbols
  java -cp quest.jar StartStop quest quest "SQR31?3" "?UTSK" "SQR31?3" >quest.addrs  
  java -cp quest.jar Disassemble quest quest quest.addrs >quest.compact

  java -cp quest.jar debug.SymbolTable quest/quest_server.st >quest_server.symbols
  java -cp quest.jar StartStop quest quest_server "SQR31?3" "?UKIL" "SQR31?3" >quest_server.addrs  
  java -cp quest.jar Disassemble quest quest_server quest.addrs >quest_server.compact
  
  These output files: quest.symbols, quest.addrs, quest.compact 
                      quest_server.symbols, quest_server.addrs, quest_symbols.compact
  have all been uploaded to the github repo for your use.
  
Inside the quest.compact and quest_server.compact files, you'll find the initial state of memory when the program
is first loaded, and the disassembled program code.  For quest, the program code is in the entry points "INIT_SHARED_DATA"
through "WRITE_OBJECT".  For quest_server, the program code is in the entry points "QUEST_SERVER" through "WRITE_OBJECT".
After "WRITE_OBJECT", you'll find the system routines these usually have a question-mark in the name, like "?RANDOM_NUMBER".  
The language runtime routines seem to have period in the name, for example "I.PROLOG".

Project plan:
1)  Work out the calling sequences MV32 calling sequences used in the quest program code.
2)  Work out the supporting runtime routines (invoked from quest, i.e., I.PROLOG, I.EPILOG, O.ON, O.REVERT, etc)
3)  Work out how array indexing and bounds checking is done in the quest program code.
4)  Work through decompiling the quest program code.  Build up models of the memory layouts used by the game.
    This would include the constants that are in program memory (things like descriptions terrain, items, monsters, etc)
    and of the shared memory files (WORLD_DATA_FILE, USER_DATA_FILE, CASTLE_DATA_FILE, etc).

Our end goal is to get to C++ code for Linux that we can compile and it will run the game using the existing data files. Quest
and Quest_Server should run in their own processes, and used memory mapped files to communicate just like on the Eagle, with
full binary data compatibility.

Do you have questions that I can answer?

